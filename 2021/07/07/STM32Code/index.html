<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>STM32Code | ConanMusk</title><meta name="keywords" content="Hal库"><meta name="author" content="YingHao Chen"><meta name="copyright" content="YingHao Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Main头文件123456789101112131415#include &lt;stdarg.h&gt;#include &quot;sys.h&quot;#include &quot;delay.h&quot;#include &quot;stdio.h&quot;#include &quot;string.h&quot;#include &quot;stdlib.h&quot;#includ">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32Code">
<meta property="og:url" content="http://example.com/2021/07/07/STM32Code/index.html">
<meta property="og:site_name" content="ConanMusk">
<meta property="og:description" content="Main头文件123456789101112131415#include &lt;stdarg.h&gt;#include &quot;sys.h&quot;#include &quot;delay.h&quot;#include &quot;stdio.h&quot;#include &quot;string.h&quot;#include &quot;stdlib.h&quot;#includ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/background.jpg">
<meta property="article:published_time" content="2021-07-07T12:42:40.000Z">
<meta property="article:modified_time" content="2022-09-30T12:24:56.435Z">
<meta property="article:author" content="YingHao Chen">
<meta property="article:tag" content="Hal库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/07/07/STM32Code/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32Code',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-30 20:24:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ConanMusk" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ConanMusk</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STM32Code</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-07T12:42:40.000Z" title="发表于 2021-07-07 20:42:40">2021-07-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-30T12:24:56.435Z" title="更新于 2022-09-30 20:24:56">2022-09-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STM32Code"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Main头文件"><a href="#Main头文件" class="headerlink" title="Main头文件"></a>Main头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arm_math.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arm_const_structs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dds_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task_manage.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="LED-使用位带操作"><a href="#LED-使用位带操作" class="headerlink" title="LED(使用位带操作)"></a>LED(使用位带操作)</h3><p>低电平点亮，注意初始化时要将电平拉高</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _LED0_ PFout(9)<span class="comment">//此处使用了自己的sys文件里面的位操作指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED1_ PFout(10)</span></span><br></pre></td></tr></table></figure>

<h3 id="三目运算符完成位带操作赋值"><a href="#三目运算符完成位带操作赋值" class="headerlink" title="三目运算符完成位带操作赋值"></a>三目运算符完成位带操作赋值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED0(n) (n ? HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET) : HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1(n) (n ? HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET) : HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET))</span></span><br></pre></td></tr></table></figure>

<p>之后就只需要给_LED0_或者_LED1_赋值</p>
<h3 id="KEY"><a href="#KEY" class="headerlink" title="KEY"></a>KEY</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引脚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY0_ PEin(4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WAK_UP_ PAin(0)</span></span><br></pre></td></tr></table></figure>

<p>上拉之后，对应GPIO口为0说明按键按下；下拉之后，GPIO口电位为1说明是按键按下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按键处理函数</span></span><br><span class="line"><span class="comment">//返回按键值</span></span><br><span class="line"><span class="comment">//mode:0,不支持连续按;1,支持连续按;</span></span><br><span class="line"><span class="comment">//0，没有任何按键按下</span></span><br><span class="line"><span class="comment">//1，WKUP按下 WK_UP</span></span><br><span class="line"><span class="comment">//注意此函数有响应优先级,KEY0&gt;KEY1&gt;KEY2&gt;WK_UP!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C文件</span></span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> u8 key_up=<span class="number">1</span>;     <span class="comment">//按键松开标志</span></span><br><span class="line">    <span class="keyword">if</span>(mode==<span class="number">1</span>)key_up=<span class="number">1</span>;    <span class="comment">//支持连按</span></span><br><span class="line">    <span class="keyword">if</span>(key_up&amp;&amp;(_KEY0_==<span class="number">0</span>||_WAK_UP_==<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">delay_ms</span>(<span class="number">10</span>);</span><br><span class="line">        key_up=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(_KEY0_==<span class="number">0</span>)       <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(_WAK_UP_==<span class="number">1</span>) <span class="keyword">return</span> WKUP_PRES;          </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_KEY0_==<span class="number">1</span>&amp;&amp;_WAK_UP_==<span class="number">0</span>)key_up=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//H文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0_PRES 	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WKUP_PRES   2</span></span><br><span class="line"><span class="comment">//功能类似使用switch case 语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Main文件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		基于switch语句的按键和led</span></span><br><span class="line"><span class="comment">*/</span>				</span><br><span class="line">		key_flag=<span class="built_in">KEY_Scan</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">switch</span>(key_flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">				_LED0_=<span class="number">0</span>;</span><br><span class="line">				_LED1_=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> WKUP_PRES:</span><br><span class="line">				_LED0_=<span class="number">1</span>;</span><br><span class="line">				_LED1_=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="h743读取引脚信息"><a href="#h743读取引脚信息" class="headerlink" title="h743读取引脚信息"></a>h743读取引脚信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0        HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)  <span class="comment">//KEY0按键PH3</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1        HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)  <span class="comment">//KEY1按键PH2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WK_UP       HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)  <span class="comment">//WKUP按键PA0</span></span></span><br></pre></td></tr></table></figure>

<h3 id="中断优先级管理"><a href="#中断优先级管理" class="headerlink" title="中断优先级管理"></a>中断优先级管理</h3><p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20210711092611718.png" alt="image-20210711092611718"></p>
<p>USART2的优先级高于TIM4，前面的越高，越被打断。</p>
<h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>一般多为按键的外部中断,需要使用回调函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*外部中断的回调函数*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">delay_ms</span>(<span class="number">100</span>);      <span class="comment">//消抖</span></span><br><span class="line">    <span class="keyword">switch</span>(GPIO_Pin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> GPIO_PIN_0:</span><br><span class="line">        <span class="comment">//这里的GPIO_PIN_0可能不一定是PA0但是，下面的判断语句可以准确指向PA0</span></span><br><span class="line">            <span class="keyword">if</span>(_WAK_UP_==<span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">				_LED1_=!_LED1_;</span><br><span class="line">               	__HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_0);<span class="comment">//清除中断标志位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GPIO_PIN_4:</span><br><span class="line">            <span class="keyword">if</span>(_KEY0_==<span class="number">1</span>)  </span><br><span class="line">            &#123;</span><br><span class="line">				_LED0_=!_LED0_;<span class="comment">//控制LED0翻转</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h3><ul>
<li><h4 id="usart-c文件"><a href="#usart-c文件" class="headerlink" title="usart.c文件"></a>usart.c文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)             </span></span><br><span class="line"><span class="comment">//标准库需要的支持函数                 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__FILE</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> handle; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">FILE __stdout;       </span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式    </span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x) </span><br><span class="line">&#123; </span><br><span class="line">	x = x; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//重定义fputc函数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕   </span></span><br><span class="line">	USART1-&gt;DR = (u8) ch;      </span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">u8 USART_RX_BUF[USART_REC_LEN];     <span class="comment">//接收缓冲,最大USART_REC_LEN个字节.</span></span><br><span class="line"><span class="comment">//接收状态</span></span><br><span class="line"><span class="comment">//bit15，	接收完成标志</span></span><br><span class="line"><span class="comment">//bit14，	接收到0x0d</span></span><br><span class="line"><span class="comment">//bit13~0，	接收到的有效字节数目</span></span><br><span class="line">u16 USART_RX_STA=<span class="number">0</span>;       <span class="comment">//接收状态标记	</span></span><br><span class="line">u8 aRxBuffer[RXBUFFERSIZE];<span class="comment">//HAL库使用的串口接收缓冲</span></span><br><span class="line">u8 USART2_TX_BUF[USART2_MAX_SEND_LEN]; 	<span class="comment">//发送缓冲,最大USART3_MAX_SEND_LEN字节</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="usart-c文件（h743）"><a href="#usart-c文件（h743）" class="headerlink" title="usart.c文件（h743）"></a>usart.c文件（h743）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="comment">//#pragma import(__use_no_semihosting)             </span></span><br><span class="line"><span class="comment">//标准库需要的支持函数                 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__FILE</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> handle; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">FILE __stdout;       </span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式    </span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x) </span><br><span class="line">&#123; </span><br><span class="line">	x = x; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//重定义fputc函数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	<span class="keyword">while</span>((USART1-&gt;ISR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕   </span></span><br><span class="line">	USART1-&gt;TDR=(u8)ch;      </span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> EN_USART1_RX   <span class="comment">//如果使能了接收</span></span></span><br><span class="line"><span class="comment">//串口1中断服务程序</span></span><br><span class="line"><span class="comment">//注意,读取USARTx-&gt;SR能避免莫名其妙的错误   	</span></span><br><span class="line">u8 USART_RX_BUF[USART_REC_LEN];     <span class="comment">//接收缓冲,最大USART_REC_LEN个字节.</span></span><br><span class="line"><span class="comment">//接收状态</span></span><br><span class="line"><span class="comment">//bit15，	接收完成标志</span></span><br><span class="line"><span class="comment">//bit14，	接收到0x0d</span></span><br><span class="line"><span class="comment">//bit13~0，	接收到的有效字节数目</span></span><br><span class="line">u16 USART_RX_STA=<span class="number">0</span>;       <span class="comment">//接收状态标记	</span></span><br><span class="line">u8 USART2_TX_BUF[USART2_MAX_SEND_LEN]; 	<span class="comment">//发送缓冲,最大USART3_MAX_SEND_LEN字节</span></span><br><span class="line">u8 aRxBuffer[RXBUFFERSIZE];<span class="comment">//HAL库使用的串口接收缓冲</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5></li>
<li><pre><code class="c++">void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
&#123;
    if(huart-&gt;Instance==USART1)//如果是串口1
    &#123;
        if((USART_RX_STA&amp;0x8000)==0)//接收未完成
        &#123;
            if(USART_RX_STA&amp;0x4000)//接收到了0x0d
            &#123;
                if(aRxBuffer[0]!=0x0a)USART_RX_STA=0;//接收错误,重新开始
                else USART_RX_STA|=0x8000;	//接收完成了 
            &#125;
            else //还没收到0X0D
            &#123;	
                if(aRxBuffer[0]==0x0d)USART_RX_STA|=0x4000;
                else
                &#123;
                    USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=aRxBuffer[0] ;
                    USART_RX_STA++;
                    if(USART_RX_STA&gt;(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
                &#125;		 
            &#125;
        &#125;

    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">+ #### 回调函数（h743）</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">  &#123;</span><br><span class="line">  	if(huart-&gt;Instance==USART1)//如果是串口1</span><br><span class="line">  	&#123;</span><br><span class="line">  		if((USART_RX_STA&amp;0x8000)==0)//接收未完成</span><br><span class="line">  		&#123;</span><br><span class="line">  			if(USART_RX_STA&amp;0x4000)//接收到了0x0d</span><br><span class="line">  			&#123;</span><br><span class="line">  				if(aRxBuffer[0]!=0x0a)USART_RX_STA=0;//接收错误,重新开始</span><br><span class="line">  				else USART_RX_STA|=0x8000;	//接收完成了 </span><br><span class="line">  			&#125;</span><br><span class="line">  			else //还没收到0X0D</span><br><span class="line">  			&#123;	</span><br><span class="line">  				if(aRxBuffer[0]==0x0d)USART_RX_STA|=0x4000;</span><br><span class="line">  				else</span><br><span class="line">  				&#123;</span><br><span class="line">  					USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=aRxBuffer[0] ;</span><br><span class="line">  					USART_RX_STA++;</span><br><span class="line">  					if(USART_RX_STA&gt;(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  </span><br><span class="line">  				&#125;		 </span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><h4 id="usart-h文件"><a href="#usart-h文件" class="headerlink" title="usart.h文件"></a>usart.h文件</h4><p>放到&#x2F;* USER CODE BEGIN Private defines <em>&#x2F;里面，不是&#x2F;</em> USER CODE BEGIN Includes *&#x2F;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USART_REC_LEN  			200  	<span class="comment">//定义最大接收字节数 200  	</span></span></span><br><span class="line"><span class="keyword">extern</span> u8  USART_RX_BUF[USART_REC_LEN]; <span class="comment">//接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 </span></span><br><span class="line"><span class="keyword">extern</span> u16 USART_RX_STA;         		<span class="comment">//接收状态标记	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RXBUFFERSIZE   1 <span class="comment">//缓存大小</span></span></span><br><span class="line"><span class="keyword">extern</span> u8 aRxBuffer[RXBUFFERSIZE];<span class="comment">//HAL库USART接收Buffer</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART2_MAX_SEND_LEN		400					<span class="comment">//最大发送缓存字节数</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="usart-h文件-h743"><a href="#usart-h文件-h743" class="headerlink" title="usart.h文件(h743)"></a>usart.h文件(h743)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EN_USART1_RX 			1		<span class="comment">//使能（1）/禁止（0）串口1接收</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_REC_LEN  			200  	<span class="comment">//定义最大接收字节数 200  	</span></span></span><br><span class="line"><span class="keyword">extern</span> u8  USART_RX_BUF[USART_REC_LEN]; <span class="comment">//接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 </span></span><br><span class="line"><span class="keyword">extern</span> u16 USART_RX_STA;         		<span class="comment">//接收状态标记	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RXBUFFERSIZE   1 <span class="comment">//缓存大小</span></span></span><br><span class="line"><span class="keyword">extern</span> u8 aRxBuffer[RXBUFFERSIZE];<span class="comment">//HAL库USART接收Buffer</span></span><br></pre></td></tr></table></figure>


</li>
<li><h6 id="打开串口接收中断"><a href="#打开串口接收中断" class="headerlink" title="打开串口接收中断"></a>打开串口接收中断</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart2 , (u8 *)aRxBuffer, RXBUFFERSIZE);<span class="comment">//该函数会开启接收中断</span></span><br></pre></td></tr></table></figure>

<p>以上的配置之后，可以调用printf函数显示，但是接收中断的使用需要在Cubemax打开串口的中断，并且配置驱动文件</p>
</li>
</ul>
<p>将下面的代码加入到串口的中断程序中去,并且添加#include “usart.h”到驱动文件头文件路径</p>
<ul>
<li><pre><code class="c++">u32 timeout=0;
#if SYSTEM_SUPPORT_OS	 	//使用OS
    OSIntEnter();    
#endif
    
    HAL_UART_IRQHandler(&amp;huart1);	//调用HAL库中断处理公用函数
    
    timeout=0;
    while (HAL_UART_GetState(&amp;huart1) != HAL_UART_STATE_READY)//等待就绪
    &#123;
     timeout++;////超时处理
     if(timeout&gt;HAL_MAX_DELAY) break;		
    
    &#125;
     
    timeout=0;
    while(HAL_UART_Receive_IT(&amp;huart1, (u8 *)aRxBuffer, RXBUFFERSIZE) != HAL_OK)//一次处理完成之后，重新开启中断并设置RxXferCount为1
    &#123;
     timeout++; //超时处理
     if(timeout&gt;HAL_MAX_DELAY) break;	
    &#125;
#if SYSTEM_SUPPORT_OS	 	//使用OS
    OSIntExit();  											 
#endif
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+  #### 驱动函数（H743）</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  	u32 timeout=0;</span><br><span class="line">      u32 maxDelay=0x1FFFF;</span><br><span class="line">  #if SYSTEM_SUPPORT_OS	 	//使用OS</span><br><span class="line">  	OSIntEnter();    </span><br><span class="line">  #endif</span><br><span class="line">  	</span><br><span class="line">  	HAL_UART_IRQHandler(&amp;huart1);	//调用HAL库中断处理公用函数</span><br><span class="line">  	</span><br><span class="line">  	timeout=0;</span><br><span class="line">      while (HAL_UART_GetState(&amp;huart1)!=HAL_UART_STATE_READY)//等待就绪</span><br><span class="line">  	&#123;</span><br><span class="line">          timeout++;////超时处理</span><br><span class="line">          if(timeout&gt;maxDelay) break;		</span><br><span class="line">  	&#125;</span><br><span class="line">       </span><br><span class="line">  	timeout=0;</span><br><span class="line">  	while(HAL_UART_Receive_IT(&amp;huart1,(u8 *)aRxBuffer, RXBUFFERSIZE)!=HAL_OK)//一次处理完成之后，重新开启中断并设置RxXferCount为1</span><br><span class="line">  	&#123;</span><br><span class="line">          timeout++; //超时处理</span><br><span class="line">          if(timeout&gt;maxDelay) break;	</span><br><span class="line">  	&#125;</span><br><span class="line">  #if SYSTEM_SUPPORT_OS	 	//使用OS</span><br><span class="line">  	OSIntExit();  											 </span><br><span class="line">  #endif</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><h4 id="u3-printf函数编写（独立的串口发送函数，不用printf也行）"><a href="#u3-printf函数编写（独立的串口发送函数，不用printf也行）" class="headerlink" title="u3_printf函数编写（独立的串口发送函数，不用printf也行）"></a>u3_printf函数编写（独立的串口发送函数，不用printf也行）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串口2,printf 函数</span></span><br><span class="line"><span class="comment">//确保一次发送数据不超过USART3_MAX_SEND_LEN字节</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u2_printf</span><span class="params">(<span class="type">char</span>* fmt,...)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	u16 i,j;</span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="built_in">va_start</span>(ap,fmt);</span><br><span class="line">	<span class="built_in">vsprintf</span>((<span class="type">char</span>*)USART2_TX_BUF,fmt,ap);</span><br><span class="line">	<span class="built_in">va_end</span>(ap);</span><br><span class="line">	i=<span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span>*)USART2_TX_BUF);<span class="comment">//此次发送数据的长度</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)<span class="comment">//循环发送数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((USART2-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕   </span></span><br><span class="line">		USART2-&gt;DR=USART2_TX_BUF[j];  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上面的函数之前要包含</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意更改串口时记得更改huart1改为对应串口的</p>
<p>测试是否成功时要看是否接对了GPIO口</p>
</li>
<li><p>串口电灯程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">			<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)</span><br><span class="line">		&#123;					   </span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span> *)USART_RX_BUF,<span class="string">&quot;LEDff&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				_LED0_=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)USART_RX_BUF,<span class="string">&quot;LEDon&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				_LED0_=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">				USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="built_in">memset</span>(USART_RX_BUF,<span class="number">0</span>,<span class="keyword">sizeof</span> USART_RX_BUF);</span><br></pre></td></tr></table></figure>

<p>发送给串口的一定是16进制的，不能直接LED0n 0d 0a</p>
<p>应该是LEDon 0d 0a对应的16进制数</p>
<p>4C 45 44 6F 6E 0D 0A（对应LEDon 0d 0a）</p>
</li>
</ul>
<h3 id="串口屏使用"><a href="#串口屏使用" class="headerlink" title="串口屏使用"></a>串口屏使用</h3><ul>
<li><p>常用指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据进去</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;add 3,0,123\xff\xff\xff&quot;</span>);<span class="comment">//反斜杠表示后面的三个0XFF</span></span><br><span class="line"><span class="comment">//清除波形数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cle 3,0\xff\xff\xff&quot;</span>);</span><br><span class="line"><span class="comment">//翻页指令</span></span><br><span class="line">page page1（后面是页面的名字）</span><br><span class="line"><span class="comment">//串口屏的波特率设置</span></span><br><span class="line">baud=<span class="number">115200</span></span><br><span class="line"><span class="comment">//串口屏发送16进制</span></span><br><span class="line">printh <span class="number">4</span>C <span class="number">45</span> <span class="number">44</span> <span class="number">66</span> <span class="number">66</span> <span class="number">0</span>D <span class="number">0</span>A</span><br><span class="line"> <span class="comment">//改变文本控件内容</span></span><br><span class="line"> t0.txt=<span class="string">&quot;vs:100&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>注意使用F4参考手册查找定时器对应的APB总线</p>
<p>TIM_GetCapture1（）；获取定时器当前值</p>
<p>TIM_SetCounter(TIM5, 0); <em>&#x2F;&#x2F;将当前计数器的值CNT设置成0</em>、</p>
<p>__HAL_TIM_DISABLE(&amp;htim5);      	&#x2F;&#x2F;关闭定时器5</p>
<p>__HAL_TIM_SET_COUNTER(&amp;htim5,0);</p>
<p>__HAL_TIM_ENABLE(&amp;htim5);		&#x2F;&#x2F;使能定时器5</p>
<ul>
<li><h5 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h5><ol>
<li><h5 id="开启定时器"><a href="#开启定时器" class="headerlink" title="开启定时器"></a>开启定时器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*开启定时器*/</span></span><br><span class="line"><span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim2);</span><br><span class="line"><span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim9);</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="定时器的中断标志的函数"><a href="#定时器的中断标志的函数" class="headerlink" title="定时器的中断标志的函数"></a>定时器的中断标志的函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除定时器初始化过程中的更新中断标志，避免定时器一启动就中断</span></span><br><span class="line">__HAL_TIM_CLEAR_IT(&amp;htim3, TIM_IT_UPDATE);		</span><br><span class="line"><span class="comment">// 使能定时器3更新中断并启动定时器</span></span><br><span class="line"><span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3);</span><br></pre></td></tr></table></figure>


</li>
<li><h5 id="回调函数-1"><a href="#回调函数-1" class="headerlink" title="回调函数"></a>回调函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数，定时器中断服务函数调用</span></span><br><span class="line"><span class="comment">//使用switch语句替代比较好</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim==(&amp;htim2))</span><br><span class="line">    &#123;</span><br><span class="line">			count_tim2++;</span><br><span class="line">			<span class="keyword">if</span>(count_tim2==<span class="number">200</span>)</span><br><span class="line">			&#123;</span><br><span class="line">        _LED1_=!_LED1_;        <span class="comment">//LED1反转</span></span><br><span class="line">				count_tim2=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">		    <span class="keyword">if</span>(htim==(&amp;htim9))</span><br><span class="line">    &#123;</span><br><span class="line">			count_tim9++;</span><br><span class="line">			<span class="keyword">if</span>(count_tim9==<span class="number">2000</span>)</span><br><span class="line">			&#123;</span><br><span class="line">        _LED0_=!_LED0_;        <span class="comment">//LED1反转</span></span><br><span class="line">				count_tim9=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>T为定时时间，Psc为预分频数，Arr为自动重装载寄存器的值，Tclk为定时器的输入时钟。<br> 这里为T为10ms，Tclk为72MHz，设置Psc为72-1，Arr为10000-1， 配置好定时器的时间后在NVIC Setting中打开定时器的更新中断，并且要使能自动重装载。</p>
<p><img src="https://img-blog.csdnimg.cn/20200615221657270.png" alt="img"></p>
</li>
</ol>
<h4 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h4><p>设置GPIO口为：复用推挽输出，上拉，高速</p>
<p><img src="https://img-blog.csdnimg.cn/20210226155949193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1OTgyMDU5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><h5 id="PWM模式"><a href="#PWM模式" class="headerlink" title="PWM模式"></a>PWM模式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PWM模式一只要TIMX_CNT&lt;TIMX_CCRX，即为有效电平，PWM模式二刚好相反</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="CCRX-对应Pulse"><a href="#CCRX-对应Pulse" class="headerlink" title="CCRX(对应Pulse)"></a>CCRX(对应Pulse)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较的值</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="CH-Porlarity"><a href="#CH-Porlarity" class="headerlink" title="CH Porlarity"></a>CH Porlarity</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">决定有效电平是高电平还是低电平 </span><br></pre></td></tr></table></figure>


</li>
<li><h5 id="改变CCRX值的函数"><a href="#改变CCRX值的函数" class="headerlink" title="改变CCRX值的函数"></a>改变CCRX值的函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置TIM通道4的占空比</span></span><br><span class="line"><span class="comment">//compare:比较值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TIM_SetTIM14Compare1</span><span class="params">(u32 compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TIM14-&gt;CCR1=compare; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定时器14的通道1所以是CCR1</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="stm32自带的改变CCRX的函数"><a href="#stm32自带的改变CCRX的函数" class="headerlink" title="stm32自带的改变CCRX的函数"></a>stm32自带的改变CCRX的函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用下面的之前要有宏定义</span><br><span class="line">USE_HAL_LEGACY（包含进去就行）</span><br><span class="line">头文件</span><br><span class="line">stm32_hal_legacy.h也要</span><br><span class="line">_HAL_TIM_SET_COMPARE(&amp;TIM3_PWM_Handler,TIM_CHANNEL_1,PWM的CCR寄存器的值);<span class="comment">//设置寄存的值</span></span><br><span class="line">_HAL_TIM_GET_COMPARE(&amp;TIM3_PWM_Handler,TIM_CHANNEL_1);<span class="comment">//得到寄存器的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="启动PWM输出"><a href="#启动PWM输出" class="headerlink" title="启动PWM输出"></a>启动PWM输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HAL_TIM_PWM_Start</span>(&amp;htim13,TIM_CHANNEL_1);</span><br><span class="line">	<span class="comment">//还有停止的函数，自己找</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="PWM输出频率计算"><a href="#PWM输出频率计算" class="headerlink" title="PWM输出频率计算"></a>PWM输出频率计算</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fpwm = <span class="number">100</span>M / ((arr+<span class="number">1</span>)*(psc+<span class="number">1</span>))(单位：Hz)</span><br><span class="line">arr 是计数值</span><br><span class="line">psc 是预分频值</span><br><span class="line">如：</span><br><span class="line"><span class="number">3.</span> 主频=<span class="number">100</span>M</span><br><span class="line"><span class="number">4.</span> arr=<span class="number">100</span><span class="number">-1</span></span><br><span class="line"><span class="number">5.</span> psc=<span class="number">1000</span><span class="number">-1</span></span><br><span class="line"><span class="number">100</span>,<span class="number">000</span>,<span class="number">000</span>/<span class="number">100</span>/<span class="number">1000</span>=<span class="number">1000</span>Hz</span><br><span class="line">比较的值是控制占空比的</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量</span></span><br><span class="line">u8 dir=<span class="number">1</span>;</span><br><span class="line">u16 led0pwmval=<span class="number">0</span>; </span><br><span class="line"><span class="comment">//while循环</span></span><br><span class="line">		<span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">		呼吸灯</span></span><br><span class="line"><span class="comment">		*************************************************/</span></span><br><span class="line">				<span class="built_in">delay_ms</span>(<span class="number">10</span>);	 	</span><br><span class="line">		<span class="keyword">if</span>(dir)led0pwmval++;				<span class="comment">//dir==1 led0pwmval递增</span></span><br><span class="line">		<span class="keyword">else</span> led0pwmval--;					<span class="comment">//dir==0 led0pwmval递减 </span></span><br><span class="line">		<span class="keyword">if</span>(led0pwmval&gt;<span class="number">300</span>)dir=<span class="number">0</span>;			<span class="comment">//led0pwmval到达300后，方向为递减</span></span><br><span class="line">		<span class="keyword">if</span>(led0pwmval==<span class="number">0</span>)dir=<span class="number">1</span>;				<span class="comment">//led0pwmval递减到0后，方向改为递增</span></span><br><span class="line">		<span class="built_in">TIM_SetTIM14Compare1</span>(led0pwmval);	<span class="comment">//修改比较值，修改占空比</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="PWM输入捕获测量频率、占空比、高电平"><a href="#PWM输入捕获测量频率、占空比、高电平" class="headerlink" title="PWM输入捕获测量频率、占空比、高电平"></a>PWM输入捕获测量频率、占空比、高电平</h4><p>主要就是配置一下初始的是上升沿捕获还是下降沿捕获，以及分频。</p>
<p>一开始是上升沿触发就需要设置GPIO为下拉。</p>
<ol>
<li><h5 id="tim-c文件"><a href="#tim-c文件" class="headerlink" title="tim.c文件"></a>tim.c文件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量</span></span><br><span class="line">u8  TIM5CH1_CAPTURE_STA=<span class="number">0</span>;							<span class="comment">//输入捕获状态		    				</span></span><br><span class="line">u32	TIM5CH1_CAPTURE_VAL;							<span class="comment">//输入捕获值(TIM5是16位)</span></span><br><span class="line">u8  count = <span class="number">0</span>;              <span class="comment">//计数+模式切换</span></span><br><span class="line">u32	TIM5CH1_CAPTURE_UP1;	<span class="comment">//输入捕获值(TIM2/TIM5是32位)</span></span><br><span class="line">u32	TIM5CH1_CAPTURE_UP2;	<span class="comment">//输入捕获值(TIM2/TIM5是32位)</span></span><br><span class="line">u32	TIM5CH1_CAPTURE_DOWN;	<span class="comment">//输入捕获值(TIM2/TIM5是32位)</span></span><br><span class="line">u32	TIM5CH1_CAPTURE_DOWN;	<span class="comment">//输入捕获值(TIM2/TIM5是32位)</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="tim-h文件"><a href="#tim-h文件" class="headerlink" title="tim.h文件"></a>tim.h文件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u8  TIM5CH1_CAPTURE_STA;							<span class="comment">//输入捕获状态		    				</span></span><br><span class="line"><span class="keyword">extern</span> u32	TIM5CH1_CAPTURE_VAL;							<span class="comment">//输入捕获值(TIM5是16位)</span></span><br><span class="line"><span class="keyword">extern</span> u32	TIM5CH1_CAPTURE_UP1;	<span class="comment">//输入捕获值(TIM2/TIM5是32位)</span></span><br><span class="line"><span class="keyword">extern</span> u32	TIM5CH1_CAPTURE_UP2;	<span class="comment">//输入捕获值(TIM2/TIM5是32位)</span></span><br><span class="line"><span class="keyword">extern</span> u8  count;              <span class="comment">//计数+模式切换</span></span><br><span class="line"><span class="keyword">extern</span> u32	TIM5CH1_CAPTURE_DOWN;	<span class="comment">//输入捕获值(TIM2/TIM5是32位)</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="main-c文件"><a href="#main-c文件" class="headerlink" title="main.c文件"></a>main.c文件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的变量</span></span><br><span class="line">	u32 temp_f=<span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> temp_d=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delay_ms</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(TIM5CH1_CAPTURE_STA&amp;<span class="number">0X80</span>)        <span class="comment">//成功捕获到了一次高电平</span></span><br><span class="line">		&#123;</span><br><span class="line">			__HAL_TIM_DISABLE(&amp;htim5);      	<span class="comment">//关闭定时器5</span></span><br><span class="line">			temp_f = TIM5CH1_CAPTURE_UP2  - TIM5CH1_CAPTURE_UP1;		</span><br><span class="line">			temp_d = TIM5CH1_CAPTURE_DOWN - TIM5CH1_CAPTURE_UP2;</span><br><span class="line">			temp_d = temp_d*<span class="number">100</span> / temp_f;</span><br><span class="line">			temp_f = <span class="number">1000000</span> / temp_f;</span><br><span class="line">			<span class="comment">//printf(&quot;high1:%lu us\r\n&quot;,TIM5CH1_CAPTURE_UP1); //打印总的高点平时间</span></span><br><span class="line">			<span class="comment">//printf(&quot;low:%lu us\r\n&quot;,TIM5CH1_CAPTURE_DOWN); //打印总的高点平时间</span></span><br><span class="line">			<span class="comment">//printf(&quot;high2:%lu us\r\n&quot;,TIM5CH1_CAPTURE_UP2); //打印总的高点平时间</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;f:%d hz\r\n\n\n\n\n&quot;</span>,temp_f); <span class="comment">//频率打印</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;d:%f \r\n\n\n\n\n&quot;</span>,temp_d); <span class="comment">//占空比打印</span></span><br><span class="line">			__HAL_TIM_SET_COUNTER(&amp;htim5,<span class="number">0</span>);</span><br><span class="line">			TIM5CH1_CAPTURE_STA=<span class="number">0</span>;          <span class="comment">//开启下一次捕获</span></span><br><span class="line">			count=<span class="number">0</span>;</span><br><span class="line">		  __HAL_TIM_ENABLE(&amp;htim5);		<span class="comment">//使能定时器5</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="驱动文件（C）（写到对应的中断函数里面）"><a href="#驱动文件（C）（写到对应的中断函数里面）" class="headerlink" title="驱动文件（C）（写到对应的中断函数里面）"></a>驱动文件（C）（写到对应的中断函数里面）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((TIM5CH1_CAPTURE_STA&amp;<span class="number">0X80</span>)==<span class="number">0</span>)<span class="comment">//还未成功捕获	</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(__HAL_TIM_GET_FLAG(&amp;htim5, TIM_IT_CC1) != RESET)<span class="comment">//捕获1发生捕获事件的标志位</span></span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">if</span>(TIM5CH1_CAPTURE_STA&amp;<span class="number">0X40</span>)		<span class="comment">//捕获到一个下降沿 		</span></span><br><span class="line">			&#123;	  	</span><br><span class="line">				TIM5CH1_CAPTURE_STA=<span class="number">0</span>;			<span class="comment">//清空				</span></span><br><span class="line"> TIM5CH1_CAPTURE_DOWN=<span class="built_in">HAL_TIM_ReadCapturedValue</span>(&amp;htim5,TIM_CHANNEL_1);<span class="comment">//获取当前的捕获值.			__HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim5,TIM_CHANNEL_1,TIM_INPUTCHANNELPOLARITY_RISING); //CC1P=0 设置为上升沿捕获</span></span><br><span class="line">				TIM5CH1_CAPTURE_STA|=<span class="number">0X80</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  								</span><br><span class="line">			&#123;</span><br><span class="line">				count++;</span><br><span class="line">				<span class="keyword">if</span>(count == <span class="number">1</span>)    <span class="comment">//还未开始,第一次捕获上升沿</span></span><br><span class="line">				&#123;</span><br><span class="line">				TIM5CH1_CAPTURE_STA=<span class="number">0</span>;			<span class="comment">//清空</span></span><br><span class="line">	TIM5CH1_CAPTURE_UP1=<span class="built_in">HAL_TIM_ReadCapturedValue</span>(&amp;htim5,TIM_CHANNEL_1);<span class="comment">//获取当前的捕获值.</span></span><br><span class="line">				<span class="comment">//TIM5CH1_CAPTURE_STA|=0X40;		//标记捕获到了上升沿</span></span><br><span class="line">				<span class="comment">//TIM_OC2PolarityConfig(TIM5,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(count == <span class="number">2</span>)    <span class="comment">//开始,第二次捕获上升沿</span></span><br><span class="line">				&#123;</span><br><span class="line">				TIM5CH1_CAPTURE_STA=<span class="number">0</span>;			<span class="comment">//清空</span></span><br><span class="line">				TIM5CH1_CAPTURE_UP2=<span class="built_in">HAL_TIM_ReadCapturedValue</span>(&amp;htim5,TIM_CHANNEL_1);<span class="comment">//获取当前的捕获值.</span></span><br><span class="line">				TIM5CH1_CAPTURE_STA|=<span class="number">0X40</span>;</span><br><span class="line">	 	__HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim5,TIM_CHANNEL_1,TIM_INPUTCHANNELPOLARITY_FALLING); <span class="comment">//CC1P=0 设置为上升沿捕获</span></span><br><span class="line">				<span class="comment">//TIM5CH1_CAPTURE_STA|=0X80;		//标记成功捕获到一次高电平脉宽</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line"></span><br><span class="line">	    </span><br><span class="line">		&#125;			     	    					   </span><br><span class="line"> 	&#125;</span><br><span class="line">	__HAL_TIM_CLEAR_IT(&amp;htim5, TIM_IT_UPDATE|TIM_IT_CC1); <span class="comment">//清除中断标志位（捕获中断以及更新中断）</span></span><br></pre></td></tr></table></figure>

<p>在驱动文件的H文件添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="打开捕获中断"><a href="#打开捕获中断" class="headerlink" title="打开捕获中断"></a>打开捕获中断</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1); </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h4 id="OLED模块使用"><a href="#OLED模块使用" class="headerlink" title="OLED模块使用"></a>OLED模块使用</h4><ul>
<li><p>Main头文件包含</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">OLED_Init</span>();			         <span class="comment">//初始化OLED  </span></span><br><span class="line"><span class="built_in">OLED_Clear</span>(<span class="number">0</span>);             <span class="comment">//清屏（全黑）</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GUI_ShowString</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;VAL:&quot;</span>,<span class="number">16</span>,<span class="number">1</span>);	      </span><br><span class="line"><span class="built_in">GUI_ShowString</span>(<span class="number">0</span>,<span class="number">16</span>,<span class="string">&quot;adc:         V&quot;</span>,<span class="number">16</span>,<span class="number">1</span>);	<span class="comment">//先在固定位置显示小数点 </span></span><br><span class="line"><span class="built_in">GUI_ShowString</span>(<span class="number">0</span>,<span class="number">32</span>,<span class="string">&quot;dac:         V&quot;</span>,<span class="number">16</span>,<span class="number">1</span>);	<span class="comment">//先在固定位置显示小数点 </span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="OLED显示函数"><a href="#OLED显示函数" class="headerlink" title="OLED显示函数"></a>OLED显示函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之后完善</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   VCC         接       DC 5V/3.3V      //OLED屏电源正</span></span><br><span class="line"><span class="comment">//   GND         接          GND          //OLED屏电源地</span></span><br><span class="line"><span class="comment">//=======================================液晶屏数据线接线==========================================//</span></span><br><span class="line"><span class="comment">//本模块默认数据总线类型为4线制SPI</span></span><br><span class="line"><span class="comment">// OLED模块               STM32单片机</span></span><br><span class="line"><span class="comment">//   MOSI        接          PB15        //OLED屏SPI写信号</span></span><br><span class="line"><span class="comment">//=======================================液晶屏控制线接线==========================================//</span></span><br><span class="line"><span class="comment">// OLED模块               STM32单片机</span></span><br><span class="line"><span class="comment">//   CS          接          PB11        //OLED屏片选控制信号</span></span><br><span class="line"><span class="comment">//   RES         接          PB12        //OLED屏复位控制信号</span></span><br><span class="line"><span class="comment">//   DC          接          PB10        //OLED屏数据/命令选择控制信号</span></span><br><span class="line"><span class="comment">//   CLK         接          PB13        //OLED屏SPI时钟信号</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8x8矩阵键盘"><a href="#8x8矩阵键盘" class="headerlink" title="8x8矩阵键盘"></a>8x8矩阵键盘</h3><p>直接导入包，调用函数即可，main.h文件包含key.h文件，调用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key=<span class="built_in">key_Scan</span>();<span class="comment">//返回按键的值，是1还是2</span></span><br></pre></td></tr></table></figure>

<h3 id="LCD屏幕驱动移植"><a href="#LCD屏幕驱动移植" class="headerlink" title="LCD屏幕驱动移植"></a>LCD屏幕驱动移植</h3><p>包含那个LCD的包就可以。</p>
<h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50303783/article/details/109086972?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162565366416780269867916%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162565366416780269867916&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-109086972.first_rank_v2_pc_rank_v29&utm_term=hal%E5%BA%93stm32ADC&spm=1018.2226.3001.4187">ADC设置参考</a></p>
<ul>
<li><p>单次连续转换+DMA转移（软件触发）</p>
</li>
<li><p>定时器触发转换+DMA转移</p>
</li>
<li><p>trigger信号触发+DMA转移</p>
<ol>
<li><h5 id="CubeMax配置"><a href="#CubeMax配置" class="headerlink" title="CubeMax配置"></a>CubeMax配置</h5><h6 id="ADC-1"><a href="#ADC-1" class="headerlink" title="ADC"></a>ADC</h6><p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20210712192022941.png" alt="image-20210712192022941"></p>
<p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20210712192116324.png" alt="image-20210712192116324"></p>
<p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20210712192149160.png" alt="image-20210712192149160"></p>
<h6 id="定时器-1"><a href="#定时器-1" class="headerlink" title="定时器"></a>定时器</h6><p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20210713215917487.png" alt="image-20210713215917487"></p>
</li>
<li><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment">AD转换完成回调函数</span></span><br><span class="line"><span class="comment">由ADC中断或者DMA传输完成调用</span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef* hadc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	flag_fft=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">HAL_ADC_Stop_DMA</span>(&amp;hadc1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HAL_TIM_Base_Start</span>(&amp;htim8);<span class="comment">//开启定时器</span></span><br><span class="line"><span class="built_in">HAL_ADC_Start_DMA</span>(&amp;hadc1, (<span class="type">uint32_t</span> *)adc1_buffer, <span class="number">4096</span>);<span class="comment">//设置传递方向</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><ul>
<li><h4 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h4><ol>
<li></li>
</ol>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">arm_status <span class="title">arm_cfft_radix4_init_f32</span><span class="params">(arm_cfft_radix4_instance_f32 * S,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uint16_t</span> fftLen,<span class="type">uint8_t</span> ifftFlag,<span class="type">uint8_t</span> bitReverseFlag)</span></span></span><br></pre></td></tr></table></figure>

<p>   在使用时，这个函数用于初始化 傅里叶变换运算的相关配置。fftLen用于确定FFT变换的长度，其默认有5种不同的设置，分别是（16&#x2F;64&#x2F;256&#x2F;1024&#x2F;4096）。本系统采用4096点傅里叶变换，故将此设置为4096。ifftFlag这个参数为0或者是1，为0时是傅里叶变换，为1时为傅里叶反变换，系统采用傅里叶变换，固将其配置为0；bitReverseFlag的取值为0或者1，为1时是按位取反，系统配置为1。最后这些参数存储在一个结构体指针S里面。</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FFT_LENGTH        4096         <span class="comment">//FFT长度，默认是4096点FFT</span></span></span><br><span class="line">arm_cfft_radix4_instance_f32 rfft;</span><br><span class="line"><span class="built_in">arm_cfft_radix4_init_f32</span>(&amp;rfft,FFT_LENGTH,<span class="number">0</span>,<span class="number">1</span>);	<span class="comment">//初始化scfft结构体，设定FFT相关参数 </span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><ol>
<li></li>
</ol>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> fft_inputbuf[FFT_LENGTH*<span class="number">2</span>];	<span class="comment">//FFT输入数组</span></span><br><span class="line"><span class="type">float</span> fft_outputbuf[FFT_LENGTH];	<span class="comment">//FFT输出数组</span></span><br></pre></td></tr></table></figure>

<p>2. </p>
</li>
<li></li>
</ul>
<p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20210717193205071.png" alt="image-20210717193205071"></p>
<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><ol>
<li><h6 id="串口-DMA"><a href="#串口-DMA" class="headerlink" title="串口+DMA"></a>串口+DMA</h6><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/104827639?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162657599516780262530596%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162657599516780262530596&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-104827639.first_rank_v2_pc_rank_v29&utm_term=stm32%E4%B8%B2%E5%8F%A3%E5%8A%A0dma&spm=1018.2226.3001.4187">参考博客</a></p>
</li>
<li></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">YingHao Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/07/STM32Code/">http://example.com/2021/07/07/STM32Code/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ConanMusk</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Hal%E5%BA%93/">Hal库</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/15/links/"><img class="prev-cover" src="https://cloud.miiiku.xyz/src/images/cover/cover-04.jpg-webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">links</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/07/STM32%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"><img class="next-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">STM32硬件知识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YingHao Chen</div><div class="author-info__description">不说话，装高手</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ConanMusk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ConanMusk" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2398457651@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Main%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">Main头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LED-%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">LED(使用位带操作)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%8C%E6%88%90%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E8%B5%8B%E5%80%BC"><span class="toc-number">3.</span> <span class="toc-text">三目运算符完成位带操作赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KEY"><span class="toc-number">4.</span> <span class="toc-text">KEY</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#h743%E8%AF%BB%E5%8F%96%E5%BC%95%E8%84%9A%E4%BF%A1%E6%81%AF"><span class="toc-number">4.1.</span> <span class="toc-text">h743读取引脚信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">中断优先级管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">外部中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3"><span class="toc-number">7.</span> <span class="toc-text">串口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#usart-c%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.</span> <span class="toc-text">usart.c文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usart-c%E6%96%87%E4%BB%B6%EF%BC%88h743%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">usart.c文件（h743）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">回调函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usart-h%E6%96%87%E4%BB%B6"><span class="toc-number">7.3.</span> <span class="toc-text">usart.h文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usart-h%E6%96%87%E4%BB%B6-h743"><span class="toc-number">7.4.</span> <span class="toc-text">usart.h文件(h743)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">7.4.0.1.</span> <span class="toc-text">打开串口接收中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u3-printf%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%EF%BC%88%E7%8B%AC%E7%AB%8B%E7%9A%84%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8D%E7%94%A8printf%E4%B9%9F%E8%A1%8C%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">u3_printf函数编写（独立的串口发送函数，不用printf也行）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%B1%8F%E4%BD%BF%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">串口屏使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">9.0.1.</span> <span class="toc-text">定时器中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">9.0.2.</span> <span class="toc-text">开启定时器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.0.3.</span> <span class="toc-text">定时器的中断标志的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">9.0.4.</span> <span class="toc-text">回调函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PWM%E8%BE%93%E5%87%BA"><span class="toc-number">9.1.</span> <span class="toc-text">PWM输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PWM%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.1.</span> <span class="toc-text">PWM模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CCRX-%E5%AF%B9%E5%BA%94Pulse"><span class="toc-number">9.1.2.</span> <span class="toc-text">CCRX(对应Pulse)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CH-Porlarity"><span class="toc-number">9.1.3.</span> <span class="toc-text">CH Porlarity</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E5%8F%98CCRX%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.4.</span> <span class="toc-text">改变CCRX值的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stm32%E8%87%AA%E5%B8%A6%E7%9A%84%E6%94%B9%E5%8F%98CCRX%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.5.</span> <span class="toc-text">stm32自带的改变CCRX的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8PWM%E8%BE%93%E5%87%BA"><span class="toc-number">9.1.6.</span> <span class="toc-text">启动PWM输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PWM%E8%BE%93%E5%87%BA%E9%A2%91%E7%8E%87%E8%AE%A1%E7%AE%97"><span class="toc-number">9.1.7.</span> <span class="toc-text">PWM输出频率计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">9.1.8.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PWM%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%B5%8B%E9%87%8F%E9%A2%91%E7%8E%87%E3%80%81%E5%8D%A0%E7%A9%BA%E6%AF%94%E3%80%81%E9%AB%98%E7%94%B5%E5%B9%B3"><span class="toc-number">9.2.</span> <span class="toc-text">PWM输入捕获测量频率、占空比、高电平</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tim-c%E6%96%87%E4%BB%B6"><span class="toc-number">9.2.1.</span> <span class="toc-text">tim.c文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tim-h%E6%96%87%E4%BB%B6"><span class="toc-number">9.2.2.</span> <span class="toc-text">tim.h文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#main-c%E6%96%87%E4%BB%B6"><span class="toc-number">9.2.3.</span> <span class="toc-text">main.c文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%96%87%E4%BB%B6%EF%BC%88C%EF%BC%89%EF%BC%88%E5%86%99%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%EF%BC%89"><span class="toc-number">9.2.4.</span> <span class="toc-text">驱动文件（C）（写到对应的中断函数里面）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%8D%95%E8%8E%B7%E4%B8%AD%E6%96%AD"><span class="toc-number">9.2.5.</span> <span class="toc-text">打开捕获中断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OLED%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">OLED模块使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">9.4.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">9.5.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OLED%E6%98%BE%E7%A4%BA%E5%87%BD%E6%95%B0"><span class="toc-number">9.6.</span> <span class="toc-text">OLED显示函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E7%BA%BF"><span class="toc-number">9.7.</span> <span class="toc-text">接线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8x8%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98"><span class="toc-number">10.</span> <span class="toc-text">8x8矩阵键盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCD%E5%B1%8F%E5%B9%95%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D"><span class="toc-number">11.</span> <span class="toc-text">LCD屏幕驱动移植</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADC"><span class="toc-number">12.</span> <span class="toc-text">ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CubeMax%E9%85%8D%E7%BD%AE"><span class="toc-number">12.0.1.</span> <span class="toc-text">CubeMax配置</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ADC-1"><span class="toc-number">12.0.1.1.</span> <span class="toc-text">ADC</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-1"><span class="toc-number">12.0.1.2.</span> <span class="toc-text">定时器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">12.0.2.</span> <span class="toc-text">函数调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FFT"><span class="toc-number">13.</span> <span class="toc-text">FFT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">核心函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">13.2.</span> <span class="toc-text">变量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA"><span class="toc-number">13.3.</span> <span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3-DMA"><span class="toc-number">13.3.0.1.</span> <span class="toc-text">串口+DMA</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/30/github/" title="Github上传本地到github仓库"><img src="/img/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Github上传本地到github仓库"/></a><div class="content"><a class="title" href="/2022/09/30/github/" title="Github上传本地到github仓库">Github上传本地到github仓库</a><time datetime="2022-09-30T12:10:40.000Z" title="发表于 2022-09-30 20:10:40">2022-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/29/hello-world/" title="Hello World"><img src="/img/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/09/29/hello-world/" title="Hello World">Hello World</a><time datetime="2022-09-29T03:14:36.825Z" title="发表于 2022-09-29 11:14:36">2022-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/17/MarkDown%E8%AF%AD%E6%B3%95/" title="MarkDown语法"><img src="/img/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MarkDown语法"/></a><div class="content"><a class="title" href="/2022/09/17/MarkDown%E8%AF%AD%E6%B3%95/" title="MarkDown语法">MarkDown语法</a><time datetime="2022-09-16T16:00:00.000Z" title="发表于 2022-09-17 00:00:00">2022-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/16/blog/" title="Hexo + Github 博客搭建简略记录"><img src="https://cloud.miiiku.xyz/src/images/cover/cover-02.jpg-webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo + Github 博客搭建简略记录"/></a><div class="content"><a class="title" href="/2022/09/16/blog/" title="Hexo + Github 博客搭建简略记录">Hexo + Github 博客搭建简略记录</a><time datetime="2022-09-15T16:00:00.000Z" title="发表于 2022-09-16 00:00:00">2022-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/links/" title="links"><img src="https://cloud.miiiku.xyz/src/images/cover/cover-04.jpg-webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="links"/></a><div class="content"><a class="title" href="/2022/09/15/links/" title="links">links</a><time datetime="2022-09-15T08:11:58.000Z" title="发表于 2022-09-15 16:11:58">2022-09-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 <i style="color:#FF6A6A;animation: announ_animation 0.8s linear infinite;" class="fa fa-heartbeat"></i> YingHao Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>